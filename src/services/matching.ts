// Auto-matching service for job assignment\nimport { locationService } from './location';\n\ninterface Tasker {\n  id: string;\n  name: string;\n  latitude: number;\n  longitude: number;\n  rating: number;\n  completionRate: number;\n  acceptanceRate: number;\n  badge: 'bronze' | 'silver' | 'gold';\n  isOnline: boolean;\n  currentJobCount: number;\n}\n\ninterface Job {\n  id: string;\n  pickupLatitude: number;\n  pickupLongitude: number;\n  dropoffLatitude: number;\n  dropoffLongitude: number;\n  type: 'delivery' | 'task' | 'errand';\n  specialization?: string;\n  priority: 'low' | 'medium' | 'high';\n}\n\ninterface MatchScore {\n  taskerId: string;\n  score: number;\n  proximity: number;\n  rating: number;\n  completionRate: number;\n  acceptanceRate: number;\n}\n\nclass MatchingService {\n  private maxConcurrentJobs = 3;\n  private proximityWeight = 0.4;\n  private ratingWeight = 0.3;\n  private completionRateWeight = 0.15;\n  private acceptanceRateWeight = 0.15;\n\n  /**\n   * Find best tasker for a job\n   */\n  findBestTasker(job: Job, availableTaskers: Tasker[]): Tasker | null {\n    // Filter eligible taskers\n    const eligibleTaskers = availableTaskers.filter(\n      (tasker) =>\n        tasker.isOnline &&\n        tasker.currentJobCount < this.maxConcurrentJobs &&\n        tasker.rating >= 4.0\n    );\n\n    if (eligibleTaskers.length === 0) {\n      return null;\n    }\n\n    // Calculate match scores\n    const scores = eligibleTaskers.map((tasker) =>\n      this.calculateMatchScore(job, tasker)\n    );\n\n    // Sort by score (descending)\n    scores.sort((a, b) => b.score - a.score);\n\n    // Return tasker with highest score\n    const bestMatch = scores[0];\n    return eligibleTaskers.find((t) => t.id === bestMatch.taskerId) || null;\n  }\n\n  /**\n   * Find multiple taskers for a job (for reassignment)\n   */\n  findTaskersForJob(job: Job, availableTaskers: Tasker[], count: number = 5): Tasker[] {\n    // Filter eligible taskers\n    const eligibleTaskers = availableTaskers.filter(\n      (tasker) =>\n        tasker.isOnline &&\n        tasker.currentJobCount < this.maxConcurrentJobs &&\n        tasker.rating >= 3.5\n    );\n\n    if (eligibleTaskers.length === 0) {\n      return [];\n    }\n\n    // Calculate match scores\n    const scores = eligibleTaskers.map((tasker) =>\n      this.calculateMatchScore(job, tasker)\n    );\n\n    // Sort by score (descending)\n    scores.sort((a, b) => b.score - a.score);\n\n    // Return top N taskers\n    return scores\n      .slice(0, count)\n      .map((score) => eligibleTaskers.find((t) => t.id === score.taskerId))\n      .filter((t) => t !== undefined) as Tasker[];\n  }\n\n  /**\n   * Calculate match score for a tasker\n   */\n  private calculateMatchScore(job: Job, tasker: Tasker): MatchScore {\n    // Calculate proximity score (0-1, 1 is closest)\n    const proximityScore = this.calculateProximityScore(\n      { latitude: job.pickupLatitude, longitude: job.pickupLongitude },\n      { latitude: tasker.latitude, longitude: tasker.longitude }\n    );\n\n    // Calculate rating score (0-1, normalized to 3.5-5.0 range)\n    const ratingScore = Math.max(0, (tasker.rating - 3.5) / 1.5);\n\n    // Completion rate score (0-1)\n    const completionRateScore = tasker.completionRate / 100;\n\n    // Acceptance rate score (0-1)\n    const acceptanceRateScore = tasker.acceptanceRate / 100;\n\n    // Calculate weighted score\n    const totalScore =\n      proximityScore * this.proximityWeight +\n      ratingScore * this.ratingWeight +\n      completionRateScore * this.completionRateWeight +\n      acceptanceRateScore * this.acceptanceRateWeight;\n\n    return {\n      taskerId: tasker.id,\n      score: totalScore,\n      proximity: proximityScore,\n      rating: ratingScore,\n      completionRate: completionRateScore,\n      acceptanceRate: acceptanceRateScore,\n    };\n  }\n\n  /**\n   * Calculate proximity score\n   */\n  private calculateProximityScore(\n    pickupLocation: { latitude: number; longitude: number },\n    taskerLocation: { latitude: number; longitude: number }\n  ): number {\n    const distance = locationService.calculateDistance(\n      {\n        latitude: pickupLocation.latitude,\n        longitude: pickupLocation.longitude,\n      },\n      {\n        latitude: taskerLocation.latitude,\n        longitude: taskerLocation.longitude,\n      }\n    );\n\n    // Distance in km, closer is better\n    // 0 km = 1.0, 5 km = 0.5, 10+ km = 0.0\n    return Math.max(0, 1 - distance / 10);\n  }\n\n  /**\n   * Estimate wait time for job\n   */\n  estimateWaitTime(availableTaskers: Tasker[]): string {\n    const onlineCount = availableTaskers.filter((t) => t.isOnline).length;\n\n    if (onlineCount === 0) {\n      return '5-10 minutes';\n    } else if (onlineCount < 5) {\n      return '2-3 minutes';\n    } else if (onlineCount < 10) {\n      return '1-2 minutes';\n    } else {\n      return '30 seconds';\n    }\n  }\n\n  /**\n   * Check if tasker is specialized for job type\n   */\n  isSpecializedForJob(tasker: Tasker, job: Job): boolean {\n    if (!job.specialization) return true;\n\n    // Check if tasker has relevant specialization\n    // This would be expanded based on actual specialization data\n    return true;\n  }\n\n  /**\n   * Get tasker availability\n   */\n  getTaskerAvailability(tasker: Tasker): 'available' | 'busy' | 'offline' {\n    if (!tasker.isOnline) {\n      return 'offline';\n    }\n    if (tasker.currentJobCount >= this.maxConcurrentJobs) {\n      return 'busy';\n    }\n    return 'available';\n  }\n\n  /**\n   * Calculate estimated earnings for job\n   */\n  calculateEstimatedEarnings(\n    distance: number,\n    jobType: 'delivery' | 'task' | 'errand'\n  ): number {\n    // Base rates per km\n    const baseRates = {\n      delivery: 0.5,\n      task: 0.75,\n      errand: 1.0,\n    };\n\n    // Minimum earnings\n    const minimumEarnings = {\n      delivery: 2.0,\n      task: 3.0,\n      errand: 5.0,\n    };\n\n    const baseRate = baseRates[jobType];\n    const minimum = minimumEarnings[jobType];\n\n    return Math.max(minimum, distance * baseRate);\n  }\n\n  /**\n   * Calculate ETA (estimated time of arrival)\n   */\n  calculateETA(\n    taskerLocation: { latitude: number; longitude: number },\n    pickupLocation: { latitude: number; longitude: number }\n  ): number {\n    // Calculate distance\n    const distance = locationService.calculateDistance(\n      taskerLocation,\n      pickupLocation\n    );\n\n    // Assume average speed of 30 km/h in urban areas\n    const averageSpeed = 30;\n    const timeInHours = distance / averageSpeed;\n    const timeInMinutes = timeInHours * 60;\n\n    return Math.ceil(timeInMinutes);\n  }\n\n  /**\n   * Update tasker weights based on performance\n   */\n  updateWeights(badge: 'bronze' | 'silver' | 'gold'): void {\n    // Adjust weights based on badge level\n    // Higher badge levels get higher priority\n    switch (badge) {\n      case 'gold':\n        this.proximityWeight = 0.3;\n        this.ratingWeight = 0.4;\n        this.completionRateWeight = 0.15;\n        this.acceptanceRateWeight = 0.15;\n        break;\n      case 'silver':\n        this.proximityWeight = 0.35;\n        this.ratingWeight = 0.35;\n        this.completionRateWeight = 0.15;\n        this.acceptanceRateWeight = 0.15;\n        break;\n      case 'bronze':\n      default:\n        this.proximityWeight = 0.4;\n        this.ratingWeight = 0.3;\n        this.completionRateWeight = 0.15;\n        this.acceptanceRateWeight = 0.15;\n        break;\n    }\n  }\n}\n\nexport const matchingService = new MatchingService();\n

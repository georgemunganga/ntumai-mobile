// Chat service for in-app messaging\nimport { websocketService } from './websocket';\n\nexport interface ChatMessage {\n  id: string;\n  chatId: string;\n  senderId: string;\n  senderName: string;\n  senderPhoto?: string;\n  message: string;\n  attachments?: string[];\n  timestamp: string;\n  isRead: boolean;\n  type: 'text' | 'image' | 'location' | 'system';\n}\n\nexport interface Chat {\n  id: string;\n  participantId: string;\n  participantName: string;\n  participantPhoto?: string;\n  lastMessage?: string;\n  lastMessageTime?: string;\n  unreadCount: number;\n  isActive: boolean;\n}\n\nclass ChatService {\n  private chats: Map<string, Chat> = new Map();\n  private messages: Map<string, ChatMessage[]> = new Map();\n  private typingUsers: Map<string, boolean> = new Map();\n\n  /**\n   * Get or create chat\n   */\n  async getOrCreateChat(\n    participantId: string,\n    participantName: string,\n    participantPhoto?: string\n  ): Promise<Chat> {\n    // Check if chat already exists\n    for (const chat of this.chats.values()) {\n      if (chat.participantId === participantId) {\n        return chat;\n      }\n    }\n\n    // Create new chat\n    const chatId = `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const newChat: Chat = {\n      id: chatId,\n      participantId,\n      participantName,\n      participantPhoto,\n      unreadCount: 0,\n      isActive: true,\n    };\n\n    this.chats.set(chatId, newChat);\n    this.messages.set(chatId, []);\n\n    return newChat;\n  }\n\n  /**\n   * Get all chats\n   */\n  getAllChats(): Chat[] {\n    return Array.from(this.chats.values()).sort(\n      (a, b) =>\n        new Date(b.lastMessageTime || 0).getTime() -\n        new Date(a.lastMessageTime || 0).getTime()\n    );\n  }\n\n  /**\n   * Get chat by ID\n   */\n  getChat(chatId: string): Chat | undefined {\n    return this.chats.get(chatId);\n  }\n\n  /**\n   * Get messages for chat\n   */\n  getMessages(chatId: string): ChatMessage[] {\n    return this.messages.get(chatId) || [];\n  }\n\n  /**\n   * Send message\n   */\n  async sendMessage(\n    chatId: string,\n    senderId: string,\n    senderName: string,\n    message: string,\n    attachments?: string[],\n    senderPhoto?: string\n  ): Promise<ChatMessage> {\n    const newMessage: ChatMessage = {\n      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      chatId,\n      senderId,\n      senderName,\n      senderPhoto,\n      message,\n      attachments,\n      timestamp: new Date().toISOString(),\n      isRead: false,\n      type: 'text',\n    };\n\n    // Add to local storage\n    const chatMessages = this.messages.get(chatId) || [];\n    chatMessages.push(newMessage);\n    this.messages.set(chatId, chatMessages);\n\n    // Update chat\n    const chat = this.chats.get(chatId);\n    if (chat) {\n      chat.lastMessage = message;\n      chat.lastMessageTime = newMessage.timestamp;\n    }\n\n    // Emit via WebSocket\n    websocketService.emitMessage(chatId, message, attachments);\n\n    return newMessage;\n  }\n\n  /**\n   * Receive message\n   */\n  receiveMessage(message: ChatMessage): void {\n    const chatMessages = this.messages.get(message.chatId) || [];\n    chatMessages.push(message);\n    this.messages.set(message.chatId, chatMessages);\n\n    // Update chat\n    const chat = this.chats.get(message.chatId);\n    if (chat) {\n      chat.lastMessage = message.message;\n      chat.lastMessageTime = message.timestamp;\n      chat.unreadCount += 1;\n    }\n  }\n\n  /**\n   * Mark message as read\n   */\n  markMessageAsRead(chatId: string, messageId: string): void {\n    const messages = this.messages.get(chatId) || [];\n    const message = messages.find((m) => m.id === messageId);\n    if (message) {\n      message.isRead = true;\n    }\n  }\n\n  /**\n   * Mark all messages as read\n   */\n  markAllMessagesAsRead(chatId: string): void {\n    const messages = this.messages.get(chatId) || [];\n    messages.forEach((m) => {\n      m.isRead = true;\n    });\n\n    const chat = this.chats.get(chatId);\n    if (chat) {\n      chat.unreadCount = 0;\n    }\n  }\n\n  /**\n   * Send typing indicator\n   */\n  sendTypingIndicator(chatId: string, isTyping: boolean): void {\n    websocketService.emitTyping(chatId, isTyping);\n  }\n\n  /**\n   * Receive typing indicator\n   */\n  receiveTypingIndicator(chatId: string, userId: string, isTyping: boolean): void {\n    const key = `${chatId}_${userId}`;\n    if (isTyping) {\n      this.typingUsers.set(key, true);\n    } else {\n      this.typingUsers.delete(key);\n    }\n  }\n\n  /**\n   * Get typing users\n   */\n  getTypingUsers(chatId: string): string[] {\n    const typingUsers: string[] = [];\n    for (const [key, isTyping] of this.typingUsers.entries()) {\n      if (isTyping && key.startsWith(chatId)) {\n        typingUsers.push(key.split('_')[1]);\n      }\n    }\n    return typingUsers;\n  }\n\n  /**\n   * Delete chat\n   */\n  deleteChat(chatId: string): void {\n    this.chats.delete(chatId);\n    this.messages.delete(chatId);\n  }\n\n  /**\n   * Clear all messages in chat\n   */\n  clearChatMessages(chatId: string): void {\n    this.messages.set(chatId, []);\n  }\n\n  /**\n   * Search messages\n   */\n  searchMessages(chatId: string, query: string): ChatMessage[] {\n    const messages = this.messages.get(chatId) || [];\n    return messages.filter((m) =>\n      m.message.toLowerCase().includes(query.toLowerCase())\n    );\n  }\n\n  /**\n   * Get unread count\n   */\n  getTotalUnreadCount(): number {\n    let total = 0;\n    for (const chat of this.chats.values()) {\n      total += chat.unreadCount;\n    }\n    return total;\n  }\n\n  /**\n   * Send location message\n   */\n  async sendLocationMessage(\n    chatId: string,\n    senderId: string,\n    senderName: string,\n    latitude: number,\n    longitude: number,\n    senderPhoto?: string\n  ): Promise<ChatMessage> {\n    const locationMessage: ChatMessage = {\n      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      chatId,\n      senderId,\n      senderName,\n      senderPhoto,\n      message: `üìç Location: ${latitude}, ${longitude}`,\n      timestamp: new Date().toISOString(),\n      isRead: false,\n      type: 'location',\n      attachments: [`geo:${latitude},${longitude}`],\n    };\n\n    const chatMessages = this.messages.get(chatId) || [];\n    chatMessages.push(locationMessage);\n    this.messages.set(chatId, chatMessages);\n\n    return locationMessage;\n  }\n\n  /**\n   * Send image message\n   */\n  async sendImageMessage(\n    chatId: string,\n    senderId: string,\n    senderName: string,\n    imageUri: string,\n    senderPhoto?: string\n  ): Promise<ChatMessage> {\n    const imageMessage: ChatMessage = {\n      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      chatId,\n      senderId,\n      senderName,\n      senderPhoto,\n      message: 'üì∑ Image',\n      attachments: [imageUri],\n      timestamp: new Date().toISOString(),\n      isRead: false,\n      type: 'image',\n    };\n\n    const chatMessages = this.messages.get(chatId) || [];\n    chatMessages.push(imageMessage);\n    this.messages.set(chatId, chatMessages);\n\n    return imageMessage;\n  }\n}\n\nexport const chatService = new ChatService();\n

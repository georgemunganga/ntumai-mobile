// @ts-nocheck
// Notification utilities import { Platform, Alert } from 'react-native'; import PushNotification, { Importance } from 'react-native-push-notification'; import PushNotificationIOS from '@react-native-community/push-notification-ios';  // Notification interfaces export interface NotificationData {   id?: string;   title: string;   message: string;   data?: Record<string, any>;   userInfo?: Record<string, any>;   badge?: number;   sound?: string;   category?: string;   actions?: string[]; }  export interface LocalNotificationOptions extends NotificationData {   date?: Date;   repeatType?: 'day' | 'week' | 'month' | 'year';   repeatTime?: number;   channelId?: string;   priority?: 'default' | 'high' | 'low' | 'max' | 'min';   vibrate?: boolean;   vibration?: number;   ongoing?: boolean;   autoCancel?: boolean;   largeIcon?: string;   smallIcon?: string;   bigText?: string;   subText?: string;   color?: string;   group?: string;   groupSummary?: boolean; }  export interface NotificationChannel {   channelId: string;   channelName: string;   channelDescription?: string;   soundName?: string;   importance?: Importance;   vibrate?: boolean; }  // Notification service class export class NotificationService {   private static instance: NotificationService;   private isInitialized = false;   private deviceToken: string | null = null;   private onTokenReceived?: (token: string) => void;   private onNotificationReceived?: (notification: any) => void;   private onNotificationOpened?: (notification: any) => void;    static getInstance(): NotificationService {     if (!NotificationService.instance) {       NotificationService.instance = new NotificationService();     }     return NotificationService.instance;   }    // Initialize notification service   initialize(options?: {     onTokenReceived?: (token: string) => void;     onNotificationReceived?: (notification: any) => void;     onNotificationOpened?: (notification: any) => void;     requestPermissions?: boolean;   }): void {     if (this.isInitialized) {       return;     }      this.onTokenReceived = options?.onTokenReceived;     this.onNotificationReceived = options?.onNotificationReceived;     this.onNotificationOpened = options?.onNotificationOpened;      // Configure push notifications     PushNotification.configure({       // Called when token is generated       onRegister: (token) => {         console.log('FCM Token:', token.token);         this.deviceToken = token.token;         this.onTokenReceived?.(token.token);       },        // Called when a remote notification is received       onNotification: (notification) => {         console.log('Notification received:', notification);                  if (notification.userInteraction) {           // Notification was opened by user           this.onNotificationOpened?.(notification);         } else {           // Notification was received while app is in foreground           this.onNotificationReceived?.(notification);         }          // Required on iOS only         if (Platform.OS === 'ios') {           notification.finish(PushNotificationIOS.FetchResult.NoData);         }       },        // Called when action is pressed       onAction: (notification) => {         console.log('Notification action pressed:', notification);       },        // Called when the user fails to register for remote notifications       onRegistrationError: (err) => {         console.error('Registration error:', err);       },        // IOS only properties       permissions: {         alert: true,         badge: true,         sound: true,       },        // Should the initial notification be popped automatically       popInitialNotification: true,        // Request permissions on init       requestPermissions: options?.requestPermissions ?? true,     });      // Create default notification channels for Android     if (Platform.OS === 'android') {       this.createDefaultChannels();     }      this.isInitialized = true;   }    // Create default notification channels   private createDefaultChannels(): void {     const channels: NotificationChannel[] = [       {         channelId: 'default',         channelName: 'Default',         channelDescription: 'Default notifications',         importance: Importance.HIGH,         vibrate: true,       },       {         channelId: 'orders',         channelName: 'Order Updates',         channelDescription: 'Notifications about order status',         importance: Importance.HIGH,         vibrate: true,       },       {         channelId: 'delivery',         channelName: 'Delivery Updates',         channelDescription: 'Notifications about delivery status',         importance: Importance.HIGH,         vibrate: true,       },       {         channelId: 'promotions',         channelName: 'Promotions',         channelDescription: 'Promotional notifications',         importance: Importance.DEFAULT,         vibrate: false,       },       {         channelId: 'driver',         channelName: 'Driver Notifications',         channelDescription: 'Notifications for drivers',         importance: Importance.HIGH,         vibrate: true,       },     ];      channels.forEach(channel => this.createChannel(channel));   }    // Create notification channel (Android only)   createChannel(channel: NotificationChannel): void {     if (Platform.OS === 'android') {       PushNotification.createChannel(         {           channelId: channel.channelId,           channelName: channel.channelName,           channelDescription: channel.channelDescription,           soundName: channel.soundName || 'default',           importance: channel.importance || Importance.HIGH,           vibrate: channel.vibrate ?? true,         },         (created) => {           console.log(`Channel ${channel.channelId} created:`, created);         }       );     }   }    // Request notification permissions   async requestPermissions(): Promise<boolean> {     try {       if (Platform.OS === 'ios') {         const permissions = await PushNotificationIOS.requestPermissions({           alert: true,           badge: true,           sound: true,         });         return permissions.alert || permissions.badge || permissions.sound;       } else {         // Android permissions are handled automatically         return true;       }     } catch (error) {       console.error('Error requesting notification permissions:', error);       return false;     }   }    // Check notification permissions   async checkPermissions(): Promise<{     alert: boolean;     badge: boolean;     sound: boolean;   }> {     if (Platform.OS === 'ios') {       return await PushNotificationIOS.checkPermissions();     } else {       // Android doesn't have granular permission checking       return { alert: true, badge: true, sound: true };     }   }    // Get device token   getDeviceToken(): string | null {     return this.deviceToken;   }    // Schedule local notification   scheduleLocalNotification(options: LocalNotificationOptions): void {     const notification: any = {       id: options.id || Date.now().toString(),       title: options.title,       message: options.message,       date: options.date || new Date(Date.now() + 1000), // Default to 1 second from now       userInfo: options.data || options.userInfo || {},       channelId: options.channelId || 'default',       soundName: options.sound || 'default',       playSound: !!options.sound,       vibrate: options.vibrate ?? true,       vibration: options.vibration || 300,       ongoing: options.ongoing || false,       autoCancel: options.autoCancel ?? true,       largeIcon: options.largeIcon || 'ic_launcher',       smallIcon: options.smallIcon || 'ic_notification',       bigText: options.bigText,       subText: options.subText,       color: options.color || '#007AFF',       group: options.group,       groupSummary: options.groupSummary || false,     };      // Set priority for Android     if (Platform.OS === 'android') {       const priorityMap = {         min: -2,         low: -1,         default: 0,         high: 1,         max: 2,       };       notification.priority = priorityMap[options.priority || 'default'];     }      // Set repeat type     if (options.repeatType) {       notification.repeatType = options.repeatType;       if (options.repeatTime) {         notification.repeatTime = options.repeatTime;       }     }      // Set badge for iOS     if (Platform.OS === 'ios' && options.badge !== undefined) {       notification.applicationIconBadgeNumber = options.badge;     }      PushNotification.localNotificationSchedule(notification);   }    // Show immediate local notification   showLocalNotification(options: NotificationData): void {     this.scheduleLocalNotification({       ...options,       date: new Date(Date.now() + 100), // Show almost immediately     });   }    // Cancel local notification   cancelLocalNotification(id: string): void {     PushNotification.cancelLocalNotifications({ id });   }    // Cancel all local notifications   cancelAllLocalNotifications(): void {     PushNotification.cancelAllLocalNotifications();   }    // Get scheduled local notifications   getScheduledLocalNotifications(callback: (notifications: any[]) => void): void {     PushNotification.getScheduledLocalNotifications(callback);   }    // Set application badge number (iOS only)   setBadgeNumber(number: number): void {     if (Platform.OS === 'ios') {       PushNotificationIOS.setApplicationIconBadgeNumber(number);     }   }    // Get application badge number (iOS only)   getBadgeNumber(callback: (number: number) => void): void {     if (Platform.OS === 'ios') {       PushNotificationIOS.getApplicationIconBadgeNumber(callback);     } else {       callback(0);     }   }    // Clear all notifications from notification center   clearAllNotifications(): void {     if (Platform.OS === 'ios') {       PushNotificationIOS.removeAllDeliveredNotifications();     } else {       PushNotification.clearLocalNotification('', 0);     }   } }  // Notification templates export const notificationTemplates = {   // Order notifications   orderPlaced: (orderNumber: string): NotificationData => ({     title: 'Order Placed Successfully!',     message: `Your order #${orderNumber} has been placed and is being prepared.`,     data: { type: 'order_placed', orderNumber },   }),    orderConfirmed: (orderNumber: string): NotificationData => ({     title: 'Order Confirmed',     message: `Your order #${orderNumber} has been confirmed by the restaurant.`,     data: { type: 'order_confirmed', orderNumber },   }),    orderPreparing: (orderNumber: string, estimatedTime: number): NotificationData => ({     title: 'Order Being Prepared',     message: `Your order #${orderNumber} is being prepared. Estimated time: ${estimatedTime} minutes.`,     data: { type: 'order_preparing', orderNumber, estimatedTime },   }),    orderReady: (orderNumber: string): NotificationData => ({     title: 'Order Ready for Pickup',     message: `Your order #${orderNumber} is ready and will be picked up soon.`,     data: { type: 'order_ready', orderNumber },   }),    orderOutForDelivery: (orderNumber: string, driverName: string): NotificationData => ({     title: 'Order Out for Delivery',     message: `${driverName} is on the way with your order #${orderNumber}.`,     data: { type: 'order_out_for_delivery', orderNumber, driverName },   }),    orderDelivered: (orderNumber: string): NotificationData => ({     title: 'Order Delivered!',     message: `Your order #${orderNumber} has been delivered. Enjoy your meal!`,     data: { type: 'order_delivered', orderNumber },   }),    orderCancelled: (orderNumber: string, reason?: string): NotificationData => ({     title: 'Order Cancelled',     message: reason        ? `Your order #${orderNumber} has been cancelled. Reason: ${reason}`       : `Your order #${orderNumber} has been cancelled.`,     data: { type: 'order_cancelled', orderNumber, reason },   }),    // Driver notifications   newOrderAssigned: (orderNumber: string, customerName: string): NotificationData => ({     title: 'New Order Assigned',     message: `You have a new delivery for ${customerName}. Order #${orderNumber}`,     data: { type: 'new_order_assigned', orderNumber, customerName },   }),    deliveryReminder: (orderNumber: string, address: string): NotificationData => ({     title: 'Delivery Reminder',     message: `Don't forget to deliver order #${orderNumber} to ${address}`,     data: { type: 'delivery_reminder', orderNumber, address },   }),    // Promotional notifications   newPromotion: (title: string, description: string, code?: string): NotificationData => ({     title: title,     message: code ? `${description} Use code: ${code}` : description,     data: { type: 'promotion', code },   }),    // General notifications   welcome: (userName: string): NotificationData => ({     title: 'Welcome to NTUMAI!',     message: `Hi ${userName}! Thanks for joining us. Start exploring delicious food nearby.`,     data: { type: 'welcome' },   }),    reviewRequest: (orderNumber: string, vendorName: string): NotificationData => ({     title: 'How was your meal?',     message: `Please rate your experience with ${vendorName} for order #${orderNumber}`,     data: { type: 'review_request', orderNumber, vendorName },   }), };  // Notification utilities export const notificationUtils = {   // Show permission request dialog   showPermissionDialog: (): void => {     Alert.alert(       'Enable Notifications',       'Get notified about your order status, delivery updates, and special offers.',       [         { text: 'Not Now', style: 'cancel' },         {           text: 'Enable',           onPress: async () => {             const service = NotificationService.getInstance();             await service.requestPermissions();           },         },       ]     );   },    // Format notification time   formatNotificationTime: (date: Date): string => {     const now = new Date();     const diffInMinutes = Math.floor((now.getTime() - date.getTime()) / (1000 * 60));          if (diffInMinutes < 1) {       return 'Just now';     } else if (diffInMinutes < 60) {       return `${diffInMinutes}m ago`;     } else if (diffInMinutes < 1440) {       const hours = Math.floor(diffInMinutes / 60);       return `${hours}h ago`;     } else {       const days = Math.floor(diffInMinutes / 1440);       return `${days}d ago`;     }   },    // Generate notification ID   generateNotificationId: (): string => {     return `notification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;   },    // Parse notification data   parseNotificationData: (notification: any): {     type: string;     data: Record<string, any>;   } => {     const data = notification.data || notification.userInfo || {};     return {       type: data.type || 'unknown',       data,     };   }, };  // Export notification service instance export const notificationService = NotificationService.getInstance();  // Export default export default {   NotificationService,   notificationService,   notificationTemplates,   notificationUtils, };


// @ts-nocheck
// Location utilities import { Platform, PermissionsAndroid, Alert } from 'react-native'; import Geolocation from '@react-native-community/geolocation';  // Location interfaces export interface Coordinates {   latitude: number;   longitude: number; }  export interface LocationData extends Coordinates {   accuracy?: number;   altitude?: number;   altitudeAccuracy?: number;   heading?: number;   speed?: number;   timestamp?: number; }  export interface Address {   street?: string;   city?: string;   state?: string;   country?: string;   postalCode?: string;   formattedAddress?: string; }  export interface LocationWithAddress extends LocationData {   address?: Address; }  // Location permission utilities export const locationPermissions = {   // Request location permission   requestPermission: async (): Promise<boolean> => {     try {       if (Platform.OS === 'android') {         const granted = await PermissionsAndroid.request(           PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,           {             title: 'Location Permission',             message: 'This app needs access to your location for delivery services.',             buttonNeutral: 'Ask Me Later',             buttonNegative: 'Cancel',             buttonPositive: 'OK',           }         );         return granted === PermissionsAndroid.RESULTS.GRANTED;       } else {         // iOS permission is handled automatically by Geolocation         return new Promise((resolve) => {           Geolocation.requestAuthorization(             () => resolve(true),             () => resolve(false)           );         });       }     } catch (error) {       console.error('Error requesting location permission:', error);       return false;     }   },    // Check if location permission is granted   checkPermission: async (): Promise<boolean> => {     try {       if (Platform.OS === 'android') {         const result = await PermissionsAndroid.check(           PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION         );         return result;       } else {         // For iOS, we'll try to get location and handle the error         return new Promise((resolve) => {           Geolocation.getCurrentPosition(             () => resolve(true),             (error) => {               if (error.code === 1) { // PERMISSION_DENIED                 resolve(false);               } else {                 resolve(true); // Other errors don't mean permission denied               }             },             { timeout: 1000 }           );         });       }     } catch (error) {       console.error('Error checking location permission:', error);       return false;     }   },    // Show permission denied alert   showPermissionDeniedAlert: (): void => {     Alert.alert(       'Location Permission Required',       'Please enable location services in your device settings to use this feature.',       [         { text: 'Cancel', style: 'cancel' },         { text: 'Open Settings', onPress: () => {           // Open device settings (implementation depends on your navigation setup)           console.log('Open device settings');         }}       ]     );   }, };  // Location services export const locationService = {   // Get current position   getCurrentPosition: async (options?: {     timeout?: number;     maximumAge?: number;     enableHighAccuracy?: boolean;   }): Promise<LocationData> => {     const defaultOptions = {       timeout: 15000,       maximumAge: 60000,       enableHighAccuracy: true,       ...options,     };      return new Promise((resolve, reject) => {       Geolocation.getCurrentPosition(         (position) => {           const { latitude, longitude, accuracy, altitude, altitudeAccuracy, heading, speed } = position.coords;           resolve({             latitude,             longitude,             accuracy,             altitude: altitude || undefined,             altitudeAccuracy: altitudeAccuracy || undefined,             heading: heading || undefined,             speed: speed || undefined,             timestamp: position.timestamp,           });         },         (error) => {           console.error('Error getting current position:', error);           reject(new Error(`Location error: ${error.message}`));         },         defaultOptions       );     });   },    // Watch position changes   watchPosition: (     onLocationChange: (location: LocationData) => void,     onError?: (error: Error) => void,     options?: {       timeout?: number;       maximumAge?: number;       enableHighAccuracy?: boolean;       distanceFilter?: number;     }   ): number => {     const defaultOptions = {       timeout: 15000,       maximumAge: 60000,       enableHighAccuracy: true,       distanceFilter: 10, // meters       ...options,     };      return Geolocation.watchPosition(       (position) => {         const { latitude, longitude, accuracy, altitude, altitudeAccuracy, heading, speed } = position.coords;         onLocationChange({           latitude,           longitude,           accuracy,           altitude: altitude || undefined,           altitudeAccuracy: altitudeAccuracy || undefined,           heading: heading || undefined,           speed: speed || undefined,           timestamp: position.timestamp,         });       },       (error) => {         console.error('Error watching position:', error);         onError?.(new Error(`Location watch error: ${error.message}`));       },       defaultOptions     );   },    // Stop watching position   clearWatch: (watchId: number): void => {     Geolocation.clearWatch(watchId);   },    // Get location with permission check   getLocationWithPermission: async (): Promise<LocationData> => {     const hasPermission = await locationPermissions.checkPermission();          if (!hasPermission) {       const granted = await locationPermissions.requestPermission();       if (!granted) {         throw new Error('Location permission denied');       }     }      return await locationService.getCurrentPosition();   }, };  // Distance and geometry utilities export const geoUtils = {   // Calculate distance between two points using Haversine formula   calculateDistance: (point1: Coordinates, point2: Coordinates): number => {     const R = 6371; // Earth's radius in kilometers     const dLat = geoUtils.toRadians(point2.latitude - point1.latitude);     const dLon = geoUtils.toRadians(point2.longitude - point1.longitude);          const a =        Math.sin(dLat / 2) * Math.sin(dLat / 2) +       Math.cos(geoUtils.toRadians(point1.latitude)) *       Math.cos(geoUtils.toRadians(point2.latitude)) *       Math.sin(dLon / 2) * Math.sin(dLon / 2);          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));     return R * c; // Distance in kilometers   },    // Convert degrees to radians   toRadians: (degrees: number): number => {     return degrees * (Math.PI / 180);   },    // Convert radians to degrees   toDegrees: (radians: number): number => {     return radians * (180 / Math.PI);   },    // Calculate bearing between two points   calculateBearing: (point1: Coordinates, point2: Coordinates): number => {     const dLon = geoUtils.toRadians(point2.longitude - point1.longitude);     const lat1 = geoUtils.toRadians(point1.latitude);     const lat2 = geoUtils.toRadians(point2.latitude);          const y = Math.sin(dLon) * Math.cos(lat2);     const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);          const bearing = geoUtils.toDegrees(Math.atan2(y, x));     return (bearing + 360) % 360; // Normalize to 0-360 degrees   },    // Check if point is within radius of center   isWithinRadius: (center: Coordinates, point: Coordinates, radiusKm: number): boolean => {     const distance = geoUtils.calculateDistance(center, point);     return distance <= radiusKm;   },    // Get bounding box for a center point and radius   getBoundingBox: (center: Coordinates, radiusKm: number): {     northEast: Coordinates;     southWest: Coordinates;   } => {     const R = 6371; // Earth's radius in kilometers     const lat = geoUtils.toRadians(center.latitude);     const lon = geoUtils.toRadians(center.longitude);          const deltaLat = radiusKm / R;     const deltaLon = Math.asin(Math.sin(deltaLat) / Math.cos(lat));          const minLat = lat - deltaLat;     const maxLat = lat + deltaLat;     const minLon = lon - deltaLon;     const maxLon = lon + deltaLon;          return {       northEast: {         latitude: geoUtils.toDegrees(maxLat),         longitude: geoUtils.toDegrees(maxLon),       },       southWest: {         latitude: geoUtils.toDegrees(minLat),         longitude: geoUtils.toDegrees(minLon),       },     };   },    // Find center point of multiple coordinates   getCenterPoint: (coordinates: Coordinates[]): Coordinates => {     if (coordinates.length === 0) {       throw new Error('Cannot find center of empty coordinates array');     }          if (coordinates.length === 1) {       return coordinates[0];     }          let x = 0;     let y = 0;     let z = 0;          coordinates.forEach(coord => {       const lat = geoUtils.toRadians(coord.latitude);       const lon = geoUtils.toRadians(coord.longitude);              x += Math.cos(lat) * Math.cos(lon);       y += Math.cos(lat) * Math.sin(lon);       z += Math.sin(lat);     });          const total = coordinates.length;     x /= total;     y /= total;     z /= total;          const centralLon = Math.atan2(y, x);     const centralSquareRoot = Math.sqrt(x * x + y * y);     const centralLat = Math.atan2(z, centralSquareRoot);          return {       latitude: geoUtils.toDegrees(centralLat),       longitude: geoUtils.toDegrees(centralLon),     };   },    // Validate coordinates   isValidCoordinates: (coordinates: Coordinates): boolean => {     const { latitude, longitude } = coordinates;     return (       typeof latitude === 'number' &&       typeof longitude === 'number' &&       latitude >= -90 &&       latitude <= 90 &&       longitude >= -180 &&       longitude <= 180 &&       !isNaN(latitude) &&       !isNaN(longitude)     );   }, };  // Address and geocoding utilities export const addressUtils = {   // Format address object to string   formatAddress: (address: Address): string => {     if (address.formattedAddress) {       return address.formattedAddress;     }          const parts = [       address.street,       address.city,       address.state,       address.postalCode,       address.country,     ].filter(Boolean);          return parts.join(', ');   },    // Parse formatted address string   parseAddress: (formattedAddress: string): Address => {     const parts = formattedAddress.split(', ');          return {       formattedAddress,       street: parts[0] || undefined,       city: parts[1] || undefined,       state: parts[2] || undefined,       postalCode: parts[3] || undefined,       country: parts[4] || undefined,     };   },    // Get short address (street and city)   getShortAddress: (address: Address): string => {     const parts = [address.street, address.city].filter(Boolean);     return parts.join(', ');   },    // Validate address completeness   isCompleteAddress: (address: Address): boolean => {     return !!(address.street && address.city && address.state);   }, };  // Location tracking utilities export class LocationTracker {   private watchId: number | null = null;   private isTracking = false;   private onLocationUpdate?: (location: LocationData) => void;   private onError?: (error: Error) => void;    constructor(     onLocationUpdate: (location: LocationData) => void,     onError?: (error: Error) => void   ) {     this.onLocationUpdate = onLocationUpdate;     this.onError = onError;   }    async startTracking(options?: {     timeout?: number;     maximumAge?: number;     enableHighAccuracy?: boolean;     distanceFilter?: number;   }): Promise<void> {     if (this.isTracking) {       return;     }      const hasPermission = await locationPermissions.checkPermission();     if (!hasPermission) {       const granted = await locationPermissions.requestPermission();       if (!granted) {         throw new Error('Location permission denied');       }     }      this.watchId = locationService.watchPosition(       this.onLocationUpdate!,       this.onError,       options     );          this.isTracking = true;   }    stopTracking(): void {     if (this.watchId !== null) {       locationService.clearWatch(this.watchId);       this.watchId = null;     }     this.isTracking = false;   }    getTrackingStatus(): boolean {     return this.isTracking;   } }  // Delivery zone utilities export const deliveryZoneUtils = {   // Check if location is within delivery zone   isInDeliveryZone: (     location: Coordinates,     deliveryZones: { center: Coordinates; radius: number }[]   ): boolean => {     return deliveryZones.some(zone =>        geoUtils.isWithinRadius(zone.center, location, zone.radius)     );   },    // Find nearest delivery zone   findNearestDeliveryZone: (     location: Coordinates,     deliveryZones: { center: Coordinates; radius: number; name?: string }[]   ): { zone: typeof deliveryZones[0]; distance: number } | null => {     let nearest: { zone: typeof deliveryZones[0]; distance: number } | null = null;          deliveryZones.forEach(zone => {       const distance = geoUtils.calculateDistance(location, zone.center);       if (!nearest || distance < nearest.distance) {         nearest = { zone, distance };       }     });          return nearest;   },    // Calculate delivery fee based on distance   calculateDeliveryFee: (     distance: number,     baseFee: number = 2.99,     perKmFee: number = 0.5,     freeDeliveryThreshold?: number   ): number => {     if (freeDeliveryThreshold && distance <= freeDeliveryThreshold) {       return 0;     }          return baseFee + (distance * perKmFee);   },    // Estimate delivery time based on distance   estimateDeliveryTime: (     distance: number,     baseTimeMinutes: number = 30,     perKmMinutes: number = 2   ): number => {     return Math.ceil(baseTimeMinutes + (distance * perKmMinutes));   }, };  // Export location utilities export const locationUtils = {   permissions: locationPermissions,   service: locationService,   geo: geoUtils,   address: addressUtils,   deliveryZone: deliveryZoneUtils,   LocationTracker, };  export default locationUtils;


// @ts-nocheck
// Permission utilities import { Platform, PermissionsAndroid, Alert, Linking } from 'react-native'; import { check, request, PERMISSIONS, RESULTS, Permission } from 'react-native-permissions';  // Permission types export type PermissionType =    | 'camera'   | 'location'   | 'locationAlways'   | 'microphone'   | 'storage'   | 'readStorage'   | 'writeStorage'   | 'contacts'   | 'calendar'   | 'photos'   | 'notifications';  export type PermissionStatus =    | 'unavailable'   | 'denied'   | 'limited'   | 'granted'   | 'blocked';  export interface PermissionResult {   status: PermissionStatus;   canAskAgain: boolean; }  // Permission mapping for different platforms const getPermissionForPlatform = (type: PermissionType): Permission | string => {   const permissions = {     camera: {       ios: PERMISSIONS.IOS.CAMERA,       android: PermissionsAndroid.PERMISSIONS.CAMERA,     },     location: {       ios: PERMISSIONS.IOS.LOCATION_WHEN_IN_USE,       android: PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,     },     locationAlways: {       ios: PERMISSIONS.IOS.LOCATION_ALWAYS,       android: PermissionsAndroid.PERMISSIONS.ACCESS_BACKGROUND_LOCATION,     },     microphone: {       ios: PERMISSIONS.IOS.MICROPHONE,       android: PermissionsAndroid.PERMISSIONS.RECORD_AUDIO,     },     storage: {       ios: PERMISSIONS.IOS.PHOTO_LIBRARY,       android: PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE,     },     readStorage: {       ios: PERMISSIONS.IOS.PHOTO_LIBRARY,       android: PermissionsAndroid.PERMISSIONS.READ_EXTERNAL_STORAGE,     },     writeStorage: {       ios: PERMISSIONS.IOS.PHOTO_LIBRARY_ADD_ONLY,       android: PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE,     },     contacts: {       ios: PERMISSIONS.IOS.CONTACTS,       android: PermissionsAndroid.PERMISSIONS.READ_CONTACTS,     },     calendar: {       ios: PERMISSIONS.IOS.CALENDARS,       android: PermissionsAndroid.PERMISSIONS.READ_CALENDAR,     },     photos: {       ios: PERMISSIONS.IOS.PHOTO_LIBRARY,       android: PermissionsAndroid.PERMISSIONS.READ_EXTERNAL_STORAGE,     },     notifications: {       ios: PERMISSIONS.IOS.NOTIFICATIONS,       android: 'android.permission.POST_NOTIFICATIONS', // Android 13+     },   };    const platformPermissions = permissions[type];   if (!platformPermissions) {     throw new Error(`Unknown permission type: ${type}`);   }    return Platform.OS === 'ios' ? platformPermissions.ios : platformPermissions.android; };  // Permission messages const getPermissionMessages = (type: PermissionType) => {   const messages = {     camera: {       title: 'Camera Permission',       message: 'This app needs access to your camera to take photos and scan QR codes.',       settingsMessage: 'Please enable camera access in your device settings to use this feature.',     },     location: {       title: 'Location Permission',       message: 'This app needs access to your location for delivery services and finding nearby restaurants.',       settingsMessage: 'Please enable location access in your device settings to use delivery services.',     },     locationAlways: {       title: 'Background Location Permission',       message: 'This app needs background location access for real-time delivery tracking.',       settingsMessage: 'Please enable "Always" location access in your device settings for delivery tracking.',     },     microphone: {       title: 'Microphone Permission',       message: 'This app needs access to your microphone for voice messages and calls.',       settingsMessage: 'Please enable microphone access in your device settings to use voice features.',     },     storage: {       title: 'Storage Permission',       message: 'This app needs access to your device storage to save and access files.',       settingsMessage: 'Please enable storage access in your device settings to save files.',     },     readStorage: {       title: 'Storage Permission',       message: 'This app needs access to read files from your device storage.',       settingsMessage: 'Please enable storage read access in your device settings.',     },     writeStorage: {       title: 'Storage Permission',       message: 'This app needs access to save files to your device storage.',       settingsMessage: 'Please enable storage write access in your device settings.',     },     contacts: {       title: 'Contacts Permission',       message: 'This app needs access to your contacts to help you share with friends.',       settingsMessage: 'Please enable contacts access in your device settings to share with friends.',     },     calendar: {       title: 'Calendar Permission',       message: 'This app needs access to your calendar to schedule delivery reminders.',       settingsMessage: 'Please enable calendar access in your device settings for reminders.',     },     photos: {       title: 'Photos Permission',       message: 'This app needs access to your photos to upload images and profile pictures.',       settingsMessage: 'Please enable photos access in your device settings to upload images.',     },     notifications: {       title: 'Notification Permission',       message: 'This app needs permission to send you notifications about orders and deliveries.',       settingsMessage: 'Please enable notifications in your device settings to receive updates.',     },   };    return messages[type] || {     title: 'Permission Required',     message: 'This app needs permission to function properly.',     settingsMessage: 'Please enable the required permission in your device settings.',   }; };  // Permission service class export class PermissionService {   private static instance: PermissionService;    static getInstance(): PermissionService {     if (!PermissionService.instance) {       PermissionService.instance = new PermissionService();     }     return PermissionService.instance;   }    // Check permission status   async checkPermission(type: PermissionType): Promise<PermissionResult> {     try {       const permission = getPermissionForPlatform(type);              if (Platform.OS === 'android' && typeof permission === 'string') {         const result = await PermissionsAndroid.check(permission);         return {           status: result ? 'granted' : 'denied',           canAskAgain: true,         };       } else if (Platform.OS === 'ios' && typeof permission !== 'string') {         const result = await check(permission);         return {           status: this.mapPermissionResult(result),           canAskAgain: result !== RESULTS.BLOCKED,         };       }              return { status: 'unavailable', canAskAgain: false };     } catch (error) {       console.error(`Error checking ${type} permission:`, error);       return { status: 'unavailable', canAskAgain: false };     }   }    // Request permission   async requestPermission(type: PermissionType): Promise<PermissionResult> {     try {       const permission = getPermissionForPlatform(type);       const messages = getPermissionMessages(type);              if (Platform.OS === 'android' && typeof permission === 'string') {         const result = await PermissionsAndroid.request(           permission,           {             title: messages.title,             message: messages.message,             buttonNeutral: 'Ask Me Later',             buttonNegative: 'Cancel',             buttonPositive: 'OK',           }         );                  const granted = result === PermissionsAndroid.RESULTS.GRANTED;         const blocked = result === PermissionsAndroid.RESULTS.NEVER_ASK_AGAIN;                  return {           status: granted ? 'granted' : blocked ? 'blocked' : 'denied',           canAskAgain: !blocked,         };       } else if (Platform.OS === 'ios' && typeof permission !== 'string') {         const result = await request(permission);         return {           status: this.mapPermissionResult(result),           canAskAgain: result !== RESULTS.BLOCKED,         };       }              return { status: 'unavailable', canAskAgain: false };     } catch (error) {       console.error(`Error requesting ${type} permission:`, error);       return { status: 'denied', canAskAgain: false };     }   }    // Request permission with rationale   async requestPermissionWithRationale(     type: PermissionType,     showRationale: boolean = true   ): Promise<PermissionResult> {     // First check current status     const currentStatus = await this.checkPermission(type);          if (currentStatus.status === 'granted') {       return currentStatus;     }          if (currentStatus.status === 'blocked') {       if (showRationale) {         this.showSettingsAlert(type);       }       return currentStatus;     }          // Show rationale if needed (Android)     if (Platform.OS === 'android' && showRationale && currentStatus.status === 'denied') {       const shouldShowRationale = await this.shouldShowRequestPermissionRationale(type);       if (shouldShowRationale) {         const userWantsToGrant = await this.showRationaleAlert(type);         if (!userWantsToGrant) {           return { status: 'denied', canAskAgain: true };         }       }     }          // Request permission     return await this.requestPermission(type);   }    // Check multiple permissions   async checkMultiplePermissions(types: PermissionType[]): Promise<Record<PermissionType, PermissionResult>> {     const results: Record<string, PermissionResult> = {};          await Promise.all(       types.map(async (type) => {         results[type] = await this.checkPermission(type);       })     );          return results as Record<PermissionType, PermissionResult>;   }    // Request multiple permissions   async requestMultiplePermissions(     types: PermissionType[],     showRationale: boolean = true   ): Promise<Record<PermissionType, PermissionResult>> {     const results: Record<string, PermissionResult> = {};          // Request permissions sequentially to avoid conflicts     for (const type of types) {       results[type] = await this.requestPermissionWithRationale(type, showRationale);     }          return results as Record<PermissionType, PermissionResult>;   }    // Check if should show rationale (Android only)   private async shouldShowRequestPermissionRationale(type: PermissionType): Promise<boolean> {     if (Platform.OS !== 'android') {       return false;     }          try {       const permission = getPermissionForPlatform(type) as string;       return await PermissionsAndroid.shouldShowRequestPermissionRationale(permission);     } catch (error) {       console.error(`Error checking rationale for ${type}:`, error);       return false;     }   }    // Show rationale alert   private showRationaleAlert(type: PermissionType): Promise<boolean> {     const messages = getPermissionMessages(type);          return new Promise((resolve) => {       Alert.alert(         messages.title,         messages.message,         [           {             text: 'Cancel',             style: 'cancel',             onPress: () => resolve(false),           },           {             text: 'Grant Permission',             onPress: () => resolve(true),           },         ]       );     });   }    // Show settings alert   private showSettingsAlert(type: PermissionType): void {     const messages = getPermissionMessages(type);          Alert.alert(       messages.title,       messages.settingsMessage,       [         {           text: 'Cancel',           style: 'cancel',         },         {           text: 'Open Settings',           onPress: () => {             Linking.openSettings();           },         },       ]     );   }    // Map permission result from react-native-permissions to our format   private mapPermissionResult(result: string): PermissionStatus {     switch (result) {       case RESULTS.UNAVAILABLE:         return 'unavailable';       case RESULTS.DENIED:         return 'denied';       case RESULTS.LIMITED:         return 'limited';       case RESULTS.GRANTED:         return 'granted';       case RESULTS.BLOCKED:         return 'blocked';       default:         return 'denied';     }   }    // Open app settings   openSettings(): void {     Linking.openSettings();   } }  // Permission utilities export const permissionUtils = {   // Check if permission is granted   isGranted: (result: PermissionResult): boolean => {     return result.status === 'granted';   },    // Check if permission is denied   isDenied: (result: PermissionResult): boolean => {     return result.status === 'denied';   },    // Check if permission is blocked   isBlocked: (result: PermissionResult): boolean => {     return result.status === 'blocked';   },    // Check if can ask for permission again   canAskAgain: (result: PermissionResult): boolean => {     return result.canAskAgain;   },    // Check if all permissions are granted   allGranted: (results: Record<string, PermissionResult>): boolean => {     return Object.values(results).every(result => result.status === 'granted');   },    // Get denied permissions   getDeniedPermissions: (results: Record<string, PermissionResult>): string[] => {     return Object.entries(results)       .filter(([_, result]) => result.status === 'denied')       .map(([type, _]) => type);   },    // Get blocked permissions   getBlockedPermissions: (results: Record<string, PermissionResult>): string[] => {     return Object.entries(results)       .filter(([_, result]) => result.status === 'blocked')       .map(([type, _]) => type);   },    // Format permission status for display   formatStatus: (status: PermissionStatus): string => {     const statusMap = {       unavailable: 'Not Available',       denied: 'Denied',       limited: 'Limited',       granted: 'Granted',       blocked: 'Blocked',     };     return statusMap[status] || 'Unknown';   }, };  // Common permission combinations export const permissionCombinations = {   // Basic app permissions   basic: ['notifications'] as PermissionType[],      // Customer app permissions   customer: ['location', 'notifications', 'camera', 'photos'] as PermissionType[],      // Driver app permissions   driver: ['location', 'locationAlways', 'notifications', 'camera', 'photos'] as PermissionType[],      // Vendor app permissions   vendor: ['notifications', 'camera', 'photos', 'storage'] as PermissionType[],      // Media permissions   media: ['camera', 'photos', 'microphone'] as PermissionType[],      // Location permissions   location: ['location'] as PermissionType[],   locationWithBackground: ['location', 'locationAlways'] as PermissionType[], };  // Export permission service instance export const permissionService = PermissionService.getInstance();  // Export default export default {   PermissionService,   permissionService,   permissionUtils,   permissionCombinations, };


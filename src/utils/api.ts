// @ts-nocheck
// API utilities import { Platform } from 'react-native'; import AsyncStorage from '@react-native-async-storage/async-storage'; import NetInfo from '@react-native-community/netinfo'; import { STORAGE_KEYS, API_CONFIG } from './constants';  // API types export interface ApiResponse<T = any> {   success: boolean;   data?: T;   message?: string;   error?: string;   errors?: Record<string, string[]>;   meta?: {     pagination?: {       page: number;       limit: number;       total: number;       totalPages: number;     };     timestamp?: string;     requestId?: string;   }; }  export interface ApiError {   message: string;   status?: number;   code?: string;   details?: any;   timestamp: string; }  export interface RequestConfig {   method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';   headers?: Record<string, string>;   body?: any;   timeout?: number;   retries?: number;   retryDelay?: number;   cache?: boolean;   cacheTimeout?: number;   requiresAuth?: boolean;   skipErrorHandling?: boolean; }  export interface ApiEndpoint {   url: string;   method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';   requiresAuth?: boolean;   timeout?: number;   retries?: number; }  // Network status let isOnline = true; let networkType = 'unknown';  // Initialize network monitoring NetInfo.fetch().then(state => {   isOnline = state.isConnected ?? false;   networkType = state.type; });  NetInfo.addEventListener(state => {   isOnline = state.isConnected ?? false;   networkType = state.type; });  // API client class export class ApiClient {   private baseURL: string;   private defaultHeaders: Record<string, string>;   private requestInterceptors: Array<(config: RequestConfig) => RequestConfig | Promise<RequestConfig>> = [];   private responseInterceptors: Array<(response: any) => any | Promise<any>> = [];   private errorInterceptors: Array<(error: ApiError) => ApiError | Promise<ApiError>> = [];   private cache: Map<string, { data: any; timestamp: number; timeout: number }> = new Map();    constructor(baseURL: string, defaultHeaders: Record<string, string> = {}) {     this.baseURL = baseURL.replace(/\/$/, ''); // Remove trailing slash     this.defaultHeaders = {       'Content-Type': 'application/json',       'Accept': 'application/json',       'User-Agent': this.getUserAgent(),       ...defaultHeaders,     };   }    // Get user agent string   private getUserAgent(): string {     const platform = Platform.OS;     const version = Platform.Version;     return `NTUMai/${API_CONFIG.VERSION} (${platform} ${version})`;   }    // Add request interceptor   addRequestInterceptor(interceptor: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>): void {     this.requestInterceptors.push(interceptor);   }    // Add response interceptor   addResponseInterceptor(interceptor: (response: any) => any | Promise<any>): void {     this.responseInterceptors.push(interceptor);   }    // Add error interceptor   addErrorInterceptor(interceptor: (error: ApiError) => ApiError | Promise<ApiError>): void {     this.errorInterceptors.push(interceptor);   }    // Set authorization header   async setAuthToken(token: string): Promise<void> {     this.defaultHeaders['Authorization'] = `Bearer ${token}`;     await AsyncStorage.setItem(STORAGE_KEYS.AUTH_TOKEN, token);   }    // Remove authorization header   async removeAuthToken(): Promise<void> {     delete this.defaultHeaders['Authorization'];     await AsyncStorage.removeItem(STORAGE_KEYS.AUTH_TOKEN);   }    // Get cached auth token   private async getAuthToken(): Promise<string | null> {     try {       return await AsyncStorage.getItem(STORAGE_KEYS.AUTH_TOKEN);     } catch (error) {       console.error('Error getting auth token:', error);       return null;     }   }    // Check network connectivity   private checkNetworkConnectivity(): void {     if (!isOnline) {       throw new ApiError({         message: 'No internet connection',         code: 'NETWORK_ERROR',         status: 0,         timestamp: new Date().toISOString(),       });     }   }    // Generate cache key   private generateCacheKey(url: string, config: RequestConfig): string {     const method = config.method || 'GET';     const body = config.body ? JSON.stringify(config.body) : '';     return `${method}:${url}:${body}`;   }    // Get cached response   private getCachedResponse(key: string): any | null {     const cached = this.cache.get(key);     if (!cached) return null;      const now = Date.now();     if (now - cached.timestamp > cached.timeout) {       this.cache.delete(key);       return null;     }      return cached.data;   }    // Set cached response   private setCachedResponse(key: string, data: any, timeout: number): void {     this.cache.set(key, {       data,       timestamp: Date.now(),       timeout,     });   }    // Clear cache   clearCache(): void {     this.cache.clear();   }    // Apply request interceptors   private async applyRequestInterceptors(config: RequestConfig): Promise<RequestConfig> {     let processedConfig = { ...config };          for (const interceptor of this.requestInterceptors) {       processedConfig = await interceptor(processedConfig);     }          return processedConfig;   }    // Apply response interceptors   private async applyResponseInterceptors(response: any): Promise<any> {     let processedResponse = response;          for (const interceptor of this.responseInterceptors) {       processedResponse = await interceptor(processedResponse);     }          return processedResponse;   }    // Apply error interceptors   private async applyErrorInterceptors(error: ApiError): Promise<ApiError> {     let processedError = error;          for (const interceptor of this.errorInterceptors) {       processedError = await interceptor(processedError);     }          return processedError;   }    // Make HTTP request   async request<T = any>(url: string, config: RequestConfig = {}): Promise<ApiResponse<T>> {     try {       // Check network connectivity       this.checkNetworkConnectivity();        // Apply request interceptors       const processedConfig = await this.applyRequestInterceptors(config);        // Prepare request       const fullUrl = url.startsWith('http') ? url : `${this.baseURL}${url}`;       const method = processedConfig.method || 'GET';       const timeout = processedConfig.timeout || API_CONFIG.TIMEOUT;       const retries = processedConfig.retries || API_CONFIG.RETRIES;       const cache = processedConfig.cache && method === 'GET';       const cacheTimeout = processedConfig.cacheTimeout || API_CONFIG.CACHE_TIMEOUT;        // Check cache for GET requests       if (cache) {         const cacheKey = this.generateCacheKey(fullUrl, processedConfig);         const cachedResponse = this.getCachedResponse(cacheKey);         if (cachedResponse) {           return cachedResponse;         }       }        // Prepare headers       let headers = { ...this.defaultHeaders, ...processedConfig.headers };        // Add auth token if required       if (processedConfig.requiresAuth && !headers['Authorization']) {         const token = await this.getAuthToken();         if (token) {           headers['Authorization'] = `Bearer ${token}`;         }       }        // Prepare body       let body: string | undefined;       if (processedConfig.body) {         if (headers['Content-Type']?.includes('application/json')) {           body = JSON.stringify(processedConfig.body);         } else if (processedConfig.body instanceof FormData) {           body = processedConfig.body as any;           delete headers['Content-Type']; // Let browser set boundary for FormData         } else {           body = processedConfig.body;         }       }        // Make request with retries       let lastError: any;       for (let attempt = 0; attempt <= retries; attempt++) {         try {           const controller = new AbortController();           const timeoutId = setTimeout(() => controller.abort(), timeout);            const response = await fetch(fullUrl, {             method,             headers,             body,             signal: controller.signal,           });            clearTimeout(timeoutId);            // Parse response           let responseData: any;           const contentType = response.headers.get('content-type');                      if (contentType?.includes('application/json')) {             responseData = await response.json();           } else {             responseData = await response.text();           }            // Handle HTTP errors           if (!response.ok) {             const error: ApiError = {               message: responseData?.message || responseData?.error || `HTTP ${response.status}`,               status: response.status,               code: responseData?.code || 'HTTP_ERROR',               details: responseData,               timestamp: new Date().toISOString(),             };              if (!processedConfig.skipErrorHandling) {               throw await this.applyErrorInterceptors(error);             }           }            // Apply response interceptors           const processedResponse = await this.applyResponseInterceptors(responseData);            // Cache successful GET requests           if (cache && response.ok) {             const cacheKey = this.generateCacheKey(fullUrl, processedConfig);             this.setCachedResponse(cacheKey, processedResponse, cacheTimeout);           }            return processedResponse;         } catch (error: any) {           lastError = error;                      // Don't retry on certain errors           if (error.name === 'AbortError' || error.status === 401 || error.status === 403) {             break;           }                      // Wait before retry           if (attempt < retries) {             const delay = processedConfig.retryDelay || API_CONFIG.RETRY_DELAY;             await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, attempt)));           }         }       }        throw lastError;     } catch (error: any) {       // Handle network errors       if (error.name === 'AbortError') {         const timeoutError: ApiError = {           message: 'Request timeout',           code: 'TIMEOUT_ERROR',           timestamp: new Date().toISOString(),         };         throw await this.applyErrorInterceptors(timeoutError);       }        if (error instanceof TypeError && error.message.includes('fetch')) {         const networkError: ApiError = {           message: 'Network error',           code: 'NETWORK_ERROR',           timestamp: new Date().toISOString(),         };         throw await this.applyErrorInterceptors(networkError);       }        // Re-throw API errors       if (error.timestamp) {         throw error;       }        // Handle unknown errors       const unknownError: ApiError = {         message: error.message || 'Unknown error',         code: 'UNKNOWN_ERROR',         details: error,         timestamp: new Date().toISOString(),       };       throw await this.applyErrorInterceptors(unknownError);     }   }    // Convenience methods   async get<T = any>(url: string, config: Omit<RequestConfig, 'method'> = {}): Promise<ApiResponse<T>> {     return this.request<T>(url, { ...config, method: 'GET' });   }    async post<T = any>(url: string, data?: any, config: Omit<RequestConfig, 'method' | 'body'> = {}): Promise<ApiResponse<T>> {     return this.request<T>(url, { ...config, method: 'POST', body: data });   }    async put<T = any>(url: string, data?: any, config: Omit<RequestConfig, 'method' | 'body'> = {}): Promise<ApiResponse<T>> {     return this.request<T>(url, { ...config, method: 'PUT', body: data });   }    async patch<T = any>(url: string, data?: any, config: Omit<RequestConfig, 'method' | 'body'> = {}): Promise<ApiResponse<T>> {     return this.request<T>(url, { ...config, method: 'PATCH', body: data });   }    async delete<T = any>(url: string, config: Omit<RequestConfig, 'method'> = {}): Promise<ApiResponse<T>> {     return this.request<T>(url, { ...config, method: 'DELETE' });   }    // Upload file   async upload<T = any>(url: string, file: any, additionalData?: Record<string, any>, config: Omit<RequestConfig, 'method' | 'body'> = {}): Promise<ApiResponse<T>> {     const formData = new FormData();     formData.append('file', file);          if (additionalData) {       Object.entries(additionalData).forEach(([key, value]) => {         formData.append(key, value);       });     }      return this.request<T>(url, {       ...config,       method: 'POST',       body: formData,       headers: {         ...config.headers,         // Don't set Content-Type for FormData, let browser handle it       },     });   } }  // API utilities export const apiUtils = {   // Create query string from object   createQueryString(params: Record<string, any>): string {     const searchParams = new URLSearchParams();          Object.entries(params).forEach(([key, value]) => {       if (value !== null && value !== undefined && value !== '') {         if (Array.isArray(value)) {           value.forEach(item => searchParams.append(key, item.toString()));         } else {           searchParams.append(key, value.toString());         }       }     });          return searchParams.toString();   },    // Parse query string to object   parseQueryString(queryString: string): Record<string, string> {     const params: Record<string, string> = {};     const searchParams = new URLSearchParams(queryString);          searchParams.forEach((value, key) => {       params[key] = value;     });          return params;   },    // Build URL with query parameters   buildUrl(baseUrl: string, params?: Record<string, any>): string {     if (!params || Object.keys(params).length === 0) {       return baseUrl;     }          const queryString = this.createQueryString(params);     const separator = baseUrl.includes('?') ? '&' : '?';     return `${baseUrl}${separator}${queryString}`;   },    // Format API response   formatResponse<T>(data: T, message?: string, meta?: any): ApiResponse<T> {     return {       success: true,       data,       message,       meta: {         ...meta,         timestamp: new Date().toISOString(),       },     };   },    // Format API error   formatError(message: string, code?: string, details?: any): ApiResponse {     return {       success: false,       error: message,       meta: {         code,         details,         timestamp: new Date().toISOString(),       },     };   },    // Check if response is successful   isSuccess<T>(response: ApiResponse<T>): response is ApiResponse<T> & { success: true; data: T } {     return response.success === true && response.data !== undefined;   },    // Check if response is error   isError(response: ApiResponse): response is ApiResponse & { success: false; error: string } {     return response.success === false;   },    // Get network status   getNetworkStatus(): { isOnline: boolean; type: string } {     return { isOnline, networkType };   },    // Validate URL   isValidUrl(url: string): boolean {     try {       new URL(url);       return true;     } catch {       return false;     }   },    // Get file extension from URL   getFileExtension(url: string): string {     try {       const pathname = new URL(url).pathname;       const extension = pathname.split('.').pop();       return extension || '';     } catch {       return '';     }   },    // Convert file to base64   fileToBase64(file: any): Promise<string> {     return new Promise((resolve, reject) => {       const reader = new FileReader();       reader.onload = () => resolve(reader.result as string);       reader.onerror = reject;       reader.readAsDataURL(file);     });   }, };  // Default API client instance export const apiClient = new ApiClient(API_CONFIG.BASE_URL);  // Setup default interceptors apiClient.addRequestInterceptor(async (config) => {   // Add request ID for tracking   config.headers = {     ...config.headers,     'X-Request-ID': Math.random().toString(36).substring(2, 15),   };      return config; });  apiClient.addResponseInterceptor(async (response) => {   // Log successful requests in development   if (__DEV__) {     console.log('API Response:', response);   }      return response; });  apiClient.addErrorInterceptor(async (error) => {   // Log errors in development   if (__DEV__) {     console.error('API Error:', error);   }      // Handle authentication errors   if (error.status === 401) {     // Clear auth token and redirect to login     await apiClient.removeAuthToken();     // You might want to emit an event or use navigation here   }      return error; });  // Export default export default {   ApiClient,   apiClient,   apiUtils, };


// @ts-nocheck
// Helper utilities  // Debounce function export const debounce = <T extends (...args: any[]) => any>(   func: T,   delay: number ): ((...args: Parameters<T>) => void) => {   let timeoutId: NodeJS.Timeout;      return (...args: Parameters<T>) => {     clearTimeout(timeoutId);     timeoutId = setTimeout(() => func(...args), delay);   }; };  // Throttle function export const throttle = <T extends (...args: any[]) => any>(   func: T,   delay: number ): ((...args: Parameters<T>) => void) => {   let lastCall = 0;      return (...args: Parameters<T>) => {     const now = Date.now();     if (now - lastCall >= delay) {       lastCall = now;       func(...args);     }   }; };  // Deep clone object export const deepClone = <T>(obj: T): T => {   if (obj === null || typeof obj !== 'object') {     return obj;   }      if (obj instanceof Date) {     return new Date(obj.getTime()) as unknown as T;   }      if (obj instanceof Array) {     return obj.map(item => deepClone(item)) as unknown as T;   }      if (typeof obj === 'object') {     const cloned = {} as T;     Object.keys(obj).forEach(key => {       (cloned as any)[key] = deepClone((obj as any)[key]);     });     return cloned;   }      return obj; };  // Deep merge objects export const deepMerge = <T extends Record<string, any>>(   target: T,   ...sources: Partial<T>[] ): T => {   if (!sources.length) return target;   const source = sources.shift();      if (isObject(target) && isObject(source)) {     for (const key in source) {       if (isObject(source[key])) {         if (!target[key]) Object.assign(target, { [key]: {} });         deepMerge(target[key], source[key]);       } else {         Object.assign(target, { [key]: source[key] });       }     }   }      return deepMerge(target, ...sources); };  // Check if value is object export const isObject = (item: any): item is Record<string, any> => {   return item && typeof item === 'object' && !Array.isArray(item); };  // Generate unique ID export const generateId = (length: number = 8): string => {   const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';   let result = '';   for (let i = 0; i < length; i++) {     result += chars.charAt(Math.floor(Math.random() * chars.length));   }   return result; };  // Generate UUID v4 export const generateUUID = (): string => {   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {     const r = Math.random() * 16 | 0;     const v = c === 'x' ? r : (r & 0x3 | 0x8);     return v.toString(16);   }); };  // Sleep/delay function export const sleep = (ms: number): Promise<void> => {   return new Promise(resolve => setTimeout(resolve, ms)); };  // Retry function with exponential backoff export const retry = async <T>(   fn: () => Promise<T>,   maxAttempts: number = 3,   baseDelay: number = 1000 ): Promise<T> => {   let lastError: Error;      for (let attempt = 1; attempt <= maxAttempts; attempt++) {     try {       return await fn();     } catch (error) {       lastError = error as Error;              if (attempt === maxAttempts) {         throw lastError;       }              const delay = baseDelay * Math.pow(2, attempt - 1);       await sleep(delay);     }   }      throw lastError!; };  // Array utilities export const arrayUtils = {   // Remove duplicates from array   unique: <T>(array: T[]): T[] => {     return [...new Set(array)];   },      // Remove duplicates by key   uniqueBy: <T, K extends keyof T>(array: T[], key: K): T[] => {     const seen = new Set();     return array.filter(item => {       const value = item[key];       if (seen.has(value)) {         return false;       }       seen.add(value);       return true;     });   },      // Group array by key   groupBy: <T, K extends keyof T>(array: T[], key: K): Record<string, T[]> => {     return array.reduce((groups, item) => {       const group = String(item[key]);       groups[group] = groups[group] || [];       groups[group].push(item);       return groups;     }, {} as Record<string, T[]>);   },      // Chunk array into smaller arrays   chunk: <T>(array: T[], size: number): T[][] => {     const chunks: T[][] = [];     for (let i = 0; i < array.length; i += size) {       chunks.push(array.slice(i, i + size));     }     return chunks;   },      // Shuffle array   shuffle: <T>(array: T[]): T[] => {     const shuffled = [...array];     for (let i = shuffled.length - 1; i > 0; i--) {       const j = Math.floor(Math.random() * (i + 1));       [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];     }     return shuffled;   },      // Get random item from array   random: <T>(array: T[]): T | undefined => {     return array[Math.floor(Math.random() * array.length)];   },      // Move item in array   move: <T>(array: T[], fromIndex: number, toIndex: number): T[] => {     const result = [...array];     const [removed] = result.splice(fromIndex, 1);     result.splice(toIndex, 0, removed);     return result;   },      // Find differences between arrays   difference: <T>(array1: T[], array2: T[]): T[] => {     return array1.filter(item => !array2.includes(item));   },      // Find intersection of arrays   intersection: <T>(array1: T[], array2: T[]): T[] => {     return array1.filter(item => array2.includes(item));   }, };  // Object utilities export const objectUtils = {   // Pick specific keys from object   pick: <T extends Record<string, any>, K extends keyof T>(     obj: T,     keys: K[]   ): Pick<T, K> => {     const result = {} as Pick<T, K>;     keys.forEach(key => {       if (key in obj) {         result[key] = obj[key];       }     });     return result;   },      // Omit specific keys from object   omit: <T extends Record<string, any>, K extends keyof T>(     obj: T,     keys: K[]   ): Omit<T, K> => {     const result = { ...obj };     keys.forEach(key => {       delete result[key];     });     return result;   },      // Check if object is empty   isEmpty: (obj: Record<string, any>): boolean => {     return Object.keys(obj).length === 0;   },      // Get nested value safely   get: (obj: any, path: string, defaultValue?: any): any => {     const keys = path.split('.');     let result = obj;          for (const key of keys) {       if (result == null || typeof result !== 'object') {         return defaultValue;       }       result = result[key];     }          return result !== undefined ? result : defaultValue;   },      // Set nested value   set: (obj: any, path: string, value: any): void => {     const keys = path.split('.');     let current = obj;          for (let i = 0; i < keys.length - 1; i++) {       const key = keys[i];       if (!(key in current) || typeof current[key] !== 'object') {         current[key] = {};       }       current = current[key];     }          current[keys[keys.length - 1]] = value;   },      // Flatten nested object   flatten: (obj: Record<string, any>, prefix: string = ''): Record<string, any> => {     const flattened: Record<string, any> = {};          Object.keys(obj).forEach(key => {       const newKey = prefix ? `${prefix}.${key}` : key;              if (isObject(obj[key])) {         Object.assign(flattened, objectUtils.flatten(obj[key], newKey));       } else {         flattened[newKey] = obj[key];       }     });          return flattened;   }, };  // String utilities export const stringUtils = {   // Convert to camelCase   toCamelCase: (str: string): string => {     return str       .replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => {         return index === 0 ? word.toLowerCase() : word.toUpperCase();       })       .replace(/\s+/g, '');   },      // Convert to snake_case   toSnakeCase: (str: string): string => {     return str       .replace(/\W+/g, ' ')       .split(/ |\s/)       .map(word => word.toLowerCase())       .join('_');   },      // Convert to kebab-case   toKebabCase: (str: string): string => {     return str       .replace(/\W+/g, ' ')       .split(/ |\s/)       .map(word => word.toLowerCase())       .join('-');   },      // Remove HTML tags   stripHtml: (str: string): string => {     return str.replace(/<[^>]*>/g, '');   },      // Escape HTML   escapeHtml: (str: string): string => {     const div = document.createElement('div');     div.textContent = str;     return div.innerHTML;   },      // Generate random string   random: (length: number = 10): string => {     const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';     let result = '';     for (let i = 0; i < length; i++) {       result += chars.charAt(Math.floor(Math.random() * chars.length));     }     return result;   }, };  // Number utilities export const numberUtils = {   // Clamp number between min and max   clamp: (value: number, min: number, max: number): number => {     return Math.min(Math.max(value, min), max);   },      // Round to specific decimal places   round: (value: number, decimals: number = 2): number => {     return Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals);   },      // Check if number is in range   inRange: (value: number, min: number, max: number): boolean => {     return value >= min && value <= max;   },      // Generate random number in range   randomInRange: (min: number, max: number): number => {     return Math.random() * (max - min) + min;   },      // Generate random integer in range   randomIntInRange: (min: number, max: number): number => {     return Math.floor(Math.random() * (max - min + 1)) + min;   },      // Convert to percentage   toPercentage: (value: number, total: number): number => {     return (value / total) * 100;   }, };  // Date utilities export const dateUtils = {   // Check if date is today   isToday: (date: Date): boolean => {     const today = new Date();     return date.toDateString() === today.toDateString();   },      // Check if date is yesterday   isYesterday: (date: Date): boolean => {     const yesterday = new Date();     yesterday.setDate(yesterday.getDate() - 1);     return date.toDateString() === yesterday.toDateString();   },      // Check if date is this week   isThisWeek: (date: Date): boolean => {     const now = new Date();     const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay()));     const endOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + 6));     return date >= startOfWeek && date <= endOfWeek;   },      // Add days to date   addDays: (date: Date, days: number): Date => {     const result = new Date(date);     result.setDate(result.getDate() + days);     return result;   },      // Add hours to date   addHours: (date: Date, hours: number): Date => {     const result = new Date(date);     result.setHours(result.getHours() + hours);     return result;   },      // Get difference in days   diffInDays: (date1: Date, date2: Date): number => {     const diffTime = Math.abs(date2.getTime() - date1.getTime());     return Math.ceil(diffTime / (1000 * 60 * 60 * 24));   },      // Get difference in hours   diffInHours: (date1: Date, date2: Date): number => {     const diffTime = Math.abs(date2.getTime() - date1.getTime());     return Math.ceil(diffTime / (1000 * 60 * 60));   },      // Get start of day   startOfDay: (date: Date): Date => {     const result = new Date(date);     result.setHours(0, 0, 0, 0);     return result;   },      // Get end of day   endOfDay: (date: Date): Date => {     const result = new Date(date);     result.setHours(23, 59, 59, 999);     return result;   }, };  // URL utilities export const urlUtils = {   // Build query string from object   buildQueryString: (params: Record<string, any>): string => {     const searchParams = new URLSearchParams();          Object.entries(params).forEach(([key, value]) => {       if (value !== null && value !== undefined) {         searchParams.append(key, String(value));       }     });          return searchParams.toString();   },      // Parse query string to object   parseQueryString: (queryString: string): Record<string, string> => {     const params = new URLSearchParams(queryString);     const result: Record<string, string> = {};          params.forEach((value, key) => {       result[key] = value;     });          return result;   },      // Join URL parts   joinUrl: (...parts: string[]): string => {     return parts       .map(part => part.replace(/^\/+|\/+$/g, ''))       .filter(part => part.length > 0)       .join('/');   }, };  // Color utilities export const colorUtils = {   // Convert hex to RGB   hexToRgb: (hex: string): { r: number; g: number; b: number } | null => {     const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);     return result       ? {           r: parseInt(result[1], 16),           g: parseInt(result[2], 16),           b: parseInt(result[3], 16),         }       : null;   },      // Convert RGB to hex   rgbToHex: (r: number, g: number, b: number): string => {     return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;   },      // Generate random color   randomColor: (): string => {     return `#${Math.floor(Math.random() * 16777215).toString(16)}`;   }, };


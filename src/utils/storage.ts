// @ts-nocheck
// Storage utilities for AsyncStorage import AsyncStorage from '@react-native-async-storage/async-storage';  // Generic storage interface export interface StorageInterface {   getItem(key: string): Promise<string | null>;   setItem(key: string, value: string): Promise<void>;   removeItem(key: string): Promise<void>;   clear(): Promise<void>;   getAllKeys(): Promise<string[]>; }  // AsyncStorage wrapper with error handling export class Storage implements StorageInterface {   async getItem(key: string): Promise<string | null> {     try {       return await AsyncStorage.getItem(key);     } catch (error) {       console.error(`Error getting item ${key}:`, error);       return null;     }   }    async setItem(key: string, value: string): Promise<void> {     try {       await AsyncStorage.setItem(key, value);     } catch (error) {       console.error(`Error setting item ${key}:`, error);       throw error;     }   }    async removeItem(key: string): Promise<void> {     try {       await AsyncStorage.removeItem(key);     } catch (error) {       console.error(`Error removing item ${key}:`, error);       throw error;     }   }    async clear(): Promise<void> {     try {       await AsyncStorage.clear();     } catch (error) {       console.error('Error clearing storage:', error);       throw error;     }   }    async getAllKeys(): Promise<string[]> {     try {       return await AsyncStorage.getAllKeys();     } catch (error) {       console.error('Error getting all keys:', error);       return [];     }   }    async multiGet(keys: string[]): Promise<[string, string | null][]> {     try {       return await AsyncStorage.multiGet(keys);     } catch (error) {       console.error('Error getting multiple items:', error);       return keys.map(key => [key, null]);     }   }    async multiSet(keyValuePairs: [string, string][]): Promise<void> {     try {       await AsyncStorage.multiSet(keyValuePairs);     } catch (error) {       console.error('Error setting multiple items:', error);       throw error;     }   }    async multiRemove(keys: string[]): Promise<void> {     try {       await AsyncStorage.multiRemove(keys);     } catch (error) {       console.error('Error removing multiple items:', error);       throw error;     }   } }  // Create storage instance export const storage = new Storage();  // Typed storage utilities export const storageUtils = {   // Store JSON data   setJSON: async <T>(key: string, data: T): Promise<void> => {     try {       const jsonString = JSON.stringify(data);       await storage.setItem(key, jsonString);     } catch (error) {       console.error(`Error storing JSON data for key ${key}:`, error);       throw error;     }   },    // Get JSON data   getJSON: async <T>(key: string, defaultValue?: T): Promise<T | null> => {     try {       const jsonString = await storage.getItem(key);       if (jsonString === null) {         return defaultValue || null;       }       return JSON.parse(jsonString) as T;     } catch (error) {       console.error(`Error parsing JSON data for key ${key}:`, error);       return defaultValue || null;     }   },    // Store boolean   setBoolean: async (key: string, value: boolean): Promise<void> => {     await storage.setItem(key, value.toString());   },    // Get boolean   getBoolean: async (key: string, defaultValue: boolean = false): Promise<boolean> => {     const value = await storage.getItem(key);     if (value === null) return defaultValue;     return value === 'true';   },    // Store number   setNumber: async (key: string, value: number): Promise<void> => {     await storage.setItem(key, value.toString());   },    // Get number   getNumber: async (key: string, defaultValue: number = 0): Promise<number> => {     const value = await storage.getItem(key);     if (value === null) return defaultValue;     const parsed = parseFloat(value);     return isNaN(parsed) ? defaultValue : parsed;   },    // Check if key exists   hasKey: async (key: string): Promise<boolean> => {     const value = await storage.getItem(key);     return value !== null;   },    // Get storage size   getStorageSize: async (): Promise<number> => {     try {       const keys = await storage.getAllKeys();       const items = await storage.multiGet(keys);       let totalSize = 0;              items.forEach(([key, value]) => {         if (value) {           totalSize += key.length + value.length;         }       });              return totalSize;     } catch (error) {       console.error('Error calculating storage size:', error);       return 0;     }   },    // Get all storage data   getAllData: async (): Promise<Record<string, any>> => {     try {       const keys = await storage.getAllKeys();       const items = await storage.multiGet(keys);       const data: Record<string, any> = {};              items.forEach(([key, value]) => {         if (value) {           try {             data[key] = JSON.parse(value);           } catch {             data[key] = value;           }         }       });              return data;     } catch (error) {       console.error('Error getting all storage data:', error);       return {};     }   },    // Clear storage by prefix   clearByPrefix: async (prefix: string): Promise<void> => {     try {       const keys = await storage.getAllKeys();       const keysToRemove = keys.filter(key => key.startsWith(prefix));       await storage.multiRemove(keysToRemove);     } catch (error) {       console.error(`Error clearing storage by prefix ${prefix}:`, error);       throw error;     }   },    // Backup storage data   backup: async (): Promise<string> => {     try {       const data = await storageUtils.getAllData();       return JSON.stringify(data);     } catch (error) {       console.error('Error creating storage backup:', error);       throw error;     }   },    // Restore storage data from backup   restore: async (backupData: string): Promise<void> => {     try {       const data = JSON.parse(backupData);       const keyValuePairs: [string, string][] = [];              Object.entries(data).forEach(([key, value]) => {         keyValuePairs.push([key, JSON.stringify(value)]);       });              await storage.multiSet(keyValuePairs);     } catch (error) {       console.error('Error restoring storage backup:', error);       throw error;     }   }, };  // Cache utilities with expiration export class CacheStorage {   private static EXPIRY_SUFFIX = '_expiry';    static async set<T>(     key: string,     data: T,     expirationMinutes?: number   ): Promise<void> {     try {       await storageUtils.setJSON(key, data);              if (expirationMinutes) {         const expiryTime = Date.now() + (expirationMinutes * 60 * 1000);         await storageUtils.setNumber(key + this.EXPIRY_SUFFIX, expiryTime);       }     } catch (error) {       console.error(`Error caching data for key ${key}:`, error);       throw error;     }   }    static async get<T>(key: string, defaultValue?: T): Promise<T | null> {     try {       // Check if data has expired       const expiryTime = await storageUtils.getNumber(key + this.EXPIRY_SUFFIX);       if (expiryTime && Date.now() > expiryTime) {         await this.remove(key);         return defaultValue || null;       }              return await storageUtils.getJSON<T>(key, defaultValue);     } catch (error) {       console.error(`Error getting cached data for key ${key}:`, error);       return defaultValue || null;     }   }    static async remove(key: string): Promise<void> {     try {       await storage.removeItem(key);       await storage.removeItem(key + this.EXPIRY_SUFFIX);     } catch (error) {       console.error(`Error removing cached data for key ${key}:`, error);       throw error;     }   }    static async clear(): Promise<void> {     try {       const keys = await storage.getAllKeys();       const cacheKeys = keys.filter(key =>          key.endsWith(this.EXPIRY_SUFFIX) ||          keys.includes(key + this.EXPIRY_SUFFIX)       );       await storage.multiRemove(cacheKeys);     } catch (error) {       console.error('Error clearing cache:', error);       throw error;     }   }    static async cleanExpired(): Promise<void> {     try {       const keys = await storage.getAllKeys();       const expiryKeys = keys.filter(key => key.endsWith(this.EXPIRY_SUFFIX));       const keysToRemove: string[] = [];              for (const expiryKey of expiryKeys) {         const expiryTime = await storageUtils.getNumber(expiryKey);         if (expiryTime && Date.now() > expiryTime) {           const dataKey = expiryKey.replace(this.EXPIRY_SUFFIX, '');           keysToRemove.push(dataKey, expiryKey);         }       }              if (keysToRemove.length > 0) {         await storage.multiRemove(keysToRemove);       }     } catch (error) {       console.error('Error cleaning expired cache:', error);     }   } }  // Secure storage utilities (for sensitive data) export const secureStorage = {   // Simple encryption/decryption (for demo purposes - use proper encryption in production)   encrypt: (text: string, key: string = 'ntumai_secret'): string => {     let result = '';     for (let i = 0; i < text.length; i++) {       const charCode = text.charCodeAt(i) ^ key.charCodeAt(i % key.length);       result += String.fromCharCode(charCode);     }     return btoa(result);   },    decrypt: (encryptedText: string, key: string = 'ntumai_secret'): string => {     try {       const text = atob(encryptedText);       let result = '';       for (let i = 0; i < text.length; i++) {         const charCode = text.charCodeAt(i) ^ key.charCodeAt(i % key.length);         result += String.fromCharCode(charCode);       }       return result;     } catch (error) {       console.error('Error decrypting data:', error);       return '';     }   },    // Store encrypted data   setSecure: async (key: string, value: string): Promise<void> => {     try {       const encrypted = secureStorage.encrypt(value);       await storage.setItem(key, encrypted);     } catch (error) {       console.error(`Error storing secure data for key ${key}:`, error);       throw error;     }   },    // Get decrypted data   getSecure: async (key: string): Promise<string | null> => {     try {       const encrypted = await storage.getItem(key);       if (!encrypted) return null;       return secureStorage.decrypt(encrypted);     } catch (error) {       console.error(`Error getting secure data for key ${key}:`, error);       return null;     }   },    // Store encrypted JSON   setSecureJSON: async <T>(key: string, data: T): Promise<void> => {     try {       const jsonString = JSON.stringify(data);       await secureStorage.setSecure(key, jsonString);     } catch (error) {       console.error(`Error storing secure JSON for key ${key}:`, error);       throw error;     }   },    // Get decrypted JSON   getSecureJSON: async <T>(key: string, defaultValue?: T): Promise<T | null> => {     try {       const jsonString = await secureStorage.getSecure(key);       if (!jsonString) return defaultValue || null;       return JSON.parse(jsonString) as T;     } catch (error) {       console.error(`Error getting secure JSON for key ${key}:`, error);       return defaultValue || null;     }   }, };  // Storage migration utilities export const migrationUtils = {   // Get current storage version   getCurrentVersion: async (): Promise<number> => {     return await storageUtils.getNumber('storage_version', 1);   },    // Set storage version   setVersion: async (version: number): Promise<void> => {     await storageUtils.setNumber('storage_version', version);   },    // Run migration   migrate: async (targetVersion: number, migrations: Record<number, () => Promise<void>>): Promise<void> => {     const currentVersion = await migrationUtils.getCurrentVersion();          if (currentVersion >= targetVersion) {       return; // No migration needed     }          console.log(`Migrating storage from version ${currentVersion} to ${targetVersion}`);          for (let version = currentVersion + 1; version <= targetVersion; version++) {       if (migrations[version]) {         try {           await migrations[version]();           await migrationUtils.setVersion(version);           console.log(`Successfully migrated to version ${version}`);         } catch (error) {           console.error(`Error migrating to version ${version}:`, error);           throw error;         }       }     }   }, };  // Export default storage instance export default storage;

